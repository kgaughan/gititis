from collections import abc
import errno
import logging
import os
import re
import secrets
import typing as t

_log = logging.getLogger(__name__)

_ACCEPTABLE_USER_RE = re.compile(r"^[a-zA-Z][a-zA-Z0-9_.-]*(@[a-zA-Z][a-zA-Z0-9.-]*)?$")


def is_safe_username(user: str) -> bool:
    match = _ACCEPTABLE_USER_RE.match(user)
    return match is not None


def read_keys(keydir: str) -> abc.Generator[tuple[str, str]]:
    """Read SSH public keys from ``keydir/*.pub``"""
    for filename in os.listdir(keydir):
        if filename.startswith("."):
            continue
        basename, ext = os.path.splitext(filename)
        if ext != ".pub":
            continue

        if not is_safe_username(basename):
            _log.warning("Unsafe SSH username in keyfile: %s", filename)
            continue

        path = os.path.join(keydir, filename)
        with open(path) as f:
            for line in f:
                line = line.rstrip("\n")
                yield (basename, line)


COMMENT = "### autogenerated by gitosis, DO NOT EDIT"


def generate_authorized_keys(keys: abc.Iterable[tuple[str, str]]) -> abc.Iterator[str]:
    yield COMMENT
    for user, key in keys:
        yield f'command="gitosis-serve {user}",no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty {key}'


_COMMAND_RE = re.compile(
    '^command="(/[^ "]+/)?gitosis-serve [^"]+",no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty .*'
)


def filter_authorized_keys(fp: t.IO) -> abc.Iterator[str]:
    """Read lines from ``fp``, filter out autogenerated ones.

    Note removes newlines.
    """
    for line in fp:
        line = line.rstrip("\n")
        if line == COMMENT:
            continue
        if _COMMAND_RE.match(line):
            continue
        yield line


def write_authorized_keys(path: str, keydir: str) -> None:
    tmp = f"{path}.{secrets.token_hex(16)}.tmp"
    try:
        in_ = open(path)  # noqa: SIM115
    except OSError as e:
        if e.errno == errno.ENOENT:
            in_ = None
        else:
            raise

    try:
        with open(tmp, "w") as out:
            if in_ is not None:
                for line in filter_authorized_keys(in_):
                    print(line, file=out)

            keygen = read_keys(keydir)
            for line in generate_authorized_keys(keygen):
                print(line, file=out)

            os.fsync(out)
    finally:
        if in_ is not None:
            in_.close()
    os.rename(tmp, path)
